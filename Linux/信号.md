# 信号的概述

信号是一个软件中断,linux环境中所使用的一种进程间异步通讯机制.看分为可靠信号和不可靠信号.共62个,信号值小于32的继承UNIX,不可靠.后面的可靠.
不可靠信号不支持信号队列或者不支持排队,产生多个相同的信号,没来得及处理的相同信号就会被丢掉,仅留下一个信号.可靠信号没来得及处理的信号会排入进程的信号队列,进程有机会来处理的时候,依次处理,信号不丢失.

# 信号早期处理函数(signal)

```c
__sighandler_t signal(int signum,__sighandler_t handler);
//参数1:要处理的信号
//参数2:信号处理函数
```

`__sighandler`是一种函数指针,返回值为void类型,有一个int的参数

signal函数安装时仅使用上述类型的函数指针作为参数,调用signal捕捉信号成功后,返回signum信号之前的处理函数;进程运行过程中收到信号signum时,转去执行handler函数.

### 存在的问题

1. 信号处理不可靠(可能被还原为默认方式)
如果一个信号在被捕获后再次发生，而程序未重新调用 signal() 注册处理函数，则该信号会按默认行为处理（例如终止程序）。
2. 不支持信号的排队
如果在处理一个 SIGINT 信号时，又触发了另一个 SIGINT 信号，第二个信号可能会被忽略，导致信号丢失。
3. 信号处理期间信号可能被屏蔽
当信号处理函数正在执行时，同一信号可能被自动屏蔽，但其他信号不会被屏蔽。这种行为可能导致竞争条件，尤其是当信号处理函数中修改了全局变量或资源时。

# 信号处理函数(sigaction)

检查或修改与指定信号想关联的处理动作.
```c
int sigaction(int signum,struct sigaction *action,struct sigaciton *oldaction;)
//参数1:要处理的信号
//参数2:信号处理函数
//参数3:之前的信号处理函数
```

### sigaction函数参数的说明

##### sa_ sigacito

sigaction的成员,用来接收信号处理函数,为一个函数指针.

##### signinfo

sa_sigaction 用来确认信号处理函数.`sa_sigaction`类型函数的第二个参数为`struct siginfo`.该结构包含信号产生原因的有关信息.\

从`siginfo`的定义可以获取该信号产生的原因以及发送信号的进程ID,进程真实用户ID(使用kill发送信号的情况).引起信号的错误的发生地址(SIGSEGV).子进程(SIGCHLD)的退出状态信息.

##### sa_mask

sa_mask是sigaction成员,用来定义在执行信号处理函数时要阻塞的信号集合;`sa_mask`成员类型为`sigset_t`,即信号集类型,每一位代表一种信号`

如果一个信号在被处理时需要阻塞另外一个或一些信号,可以将需要阻塞的信号设置在`sa_mask`屏蔽信号集中,这样在设置信号处理函数的时候,被屏蔽的信号集合会传递给`sigaction1结构

进程需要阻塞信号可使用`sigprocmask`来设置屏蔽信号集
```c
int sigprocmask(int how,sigset_t *set,sigset_t *oset);
//参数1:修改屏蔽信号机的方式
//参数2:本次要按照how的方式操作的信号集合指针
//参数3:修改前的信屏蔽信号集指针
```                                
# 信号其他相关函数

### kill和raise

产生信号的一种方法是由某个进程调用`kill`函数发送信号给指定进程或进程组,kill也是一个`Shell`命令

`kill -9 3234`:表示向进程ID为3234的进程发送一个编号为9(SIGILL)的信号

```c
int kill(pid_t pid;int signo);
//参数1:目标进程PID
//参数2:要发送的信号
```
pid参数说明
* pid>0:PID为pid的进程
* pid=0:与当前进程在同一组的所有进程
* pid=-1:有权限向其他发送信号的所有进程
* pid<0:进程组号PGID为pid的绝对值&&有权向其他发送信号的所有进程

```c
int raise(int signo);
//参数:要发送的信号
```

`raise`函数发送信号的目标是明确的,是向调用`raise`函数的进程自己发送一个信号.

### alarm与pause

```c
int alarm(int seconds);
参数:定时器设置的描述
```
调用后,到了设定的时间,系统向调用alarm的进程发送一个`SIGALRM`信号.

alarm函数一个进程只能调用一次,第二次调用时,之前的会失效,只返回上次所定时间到当前余留下的秒数,闹铃被本次调用重置.

```c
int pause(void);
```
使调用该函数的进程主动进入阻塞状态.
